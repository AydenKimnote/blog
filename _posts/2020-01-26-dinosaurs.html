<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>2021-10-19 vmware로 centos7 접속후 gnuboard로 사이트 만들기</title>
</head>
<body>
오늘은 원래 vmware ESXi를 이용하여 gnuboard를 작성하는 법을 배웠으나.... <br>
컴퓨터의 사양 딸림으로 인해 vmware workstation에서 다시 gnuboard를 만들어보자...<br>
<br>
<br>
CentOS7에서 구축한다.
<br>
<br>
DNS 서버 : 도메인주소를 IP주소로 변환하는 서버<br>
WEB 서버 : 웹 페이지를 제공하는 서버<br>
DB 서버 : 자료를 저장하는 서버<br>
APM  = (Apache + PHP + MySQL)
<br>
+------+<br>
|  DNS |<br>
|  WEB |<br>
|   DB |<br>
+------+ <br>
<br>
위에서 설정한 조건에 맞게 문제를 해결한다.
<br>
<br>
<br>
1. 리눅스 서버 설치<br>
- 이 단계에서는 서버로 활용하기 위해서 CentOS7를 설치해주고, IP주소와 파티션을 설정한다.<br>
- 파티션을 확인하는 명령어 = [root@www ~]# fdisk -l<br>
- 파티션의 용량과 mount된 디텍토리 주소 확인하는 명령어 = [root@www ~]# df<br>
- swap : HDD를 메모리처럼 사용하는 기술, 리눅스 설치할 때 반드시 swap 파티션을 나눠줘야 한다. (swap 파티션 용량은 일반적으로 메모리의 2배의 크기로 설정한다.)
<br>
<br>
<br>
2, 호스트명을 설정하는 방법<br>
- 방법1, hostnamectl 명령어를 이용해서 변경하는 방법<br>
- 방법2, nmtui 명령어를 이용해서 변경하는 방법<br>
- 호스트명이 저장되는 파일 : /etc/hostname<br>
- 현재 호스트명을 확인하는 명령어 : hostname<br>
<br>
<br>
호스트명을 변경하고 /etc/hosts 파일에 호스트명을 추가한다.<br>
<br>
# vi /etc/hosts<br>
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4<br>
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6<br>
192.168.50.30 server1.kr www.server1.kr<br>
192.168.50.30 server2.kr www.server2.kr<br>
192.168.50.30 server3.kr www.server3.kr<br>
<br>
​<br>
<br>
DNS 설정 정보를 확인한다.<br>
<br>
<br>
[root@www ~]# cat /etc/resolv.conf<br>
# Generated by NetworkManager<br>
search server1.kr<br>
nameserver 192.168.50.20<br>
<br>
<br>
3. 도메인 설정<br>
- server1.kr, sever2.kr, server3.kr <br>
- 192.168.50.25 DNS 서버에 도메인 정보를 설정한다.<br>
- 도메인 정보<br>
<br>
도메인명 포워드 존파일 리버스 존파일 IP주소 <br>
<br>
server1.kr server1.kr.zone x 192.168.50.20<br>
server2.kr server2.kr.zone x 192.168.50.20<br>
server3.kr server3.kr.zone x 192.168.50.20<br>
<br>
<br>
<br>
2.1. 도메인 등록<br>
네임서버 전체 환경 설정 파일 : /etc/named.conf<br>
도메인 설정 파일 : /etc/named.rfc1912.zones<br>
<br>
<br>
<br>
DNS 패키지인 bind를 설치한다.<br>
<br>
# yum -y install bind*<br>
<br>
만약 bind*가 설치 되지 않는다면 vi /etc/sysconfig/network-scripts/ifcfg-ens33에 들어가서<br>
맨 밑에 DNS를 추가해줘야한다. DNS1=8.8.8.8 이후 systemctl restart network<br>
<br>
<br>
<br>
/etc/named.conf 파일을 아래와 같이 설정한다.<br>
아래 두 개의 설정을 no로 설정해야 클라이언트에서 yum 요청시 패키지를 설치할 수 있다.<br>
<br>
dnssec-enable no;<br>
dnssec-validation no;<br>
<br>
[root@server1 ~]# vi /etc/named.conf<br>
listen-on port 53 { 192.168.50.20; };<br>
// listen-on-v6 port 53 { ::1; };<br>
allow-query { any; };<br>
allow-transfer { none; };<br>
version "";<br>
recursion yes;<br>
dnssec-enable no;<br>
dnssec-validation no;<br>
<br>
<br>
<br>
/etc/named.rfc1912.zones 파일에 도메인을 등록한다.<br>
등록하는 형식은 아래처럼 등록해야 한다.<br>
<br>
zone "도메인명" IN {<br>
type 네임서버종류;<br>
file "포워드존파일";<br>
allow-update { none; };<br>
};<br>
<br>
<br>
<br>
/etc/named.rfc1912.zones 파일에 도메인을 설정한다.<br>
<br>
[root@server1 ~]# vi /etc/named.rfc1912.zones<br>
:<br>
:(생략)<br>
zone "server1.kr" IN { type master; file "server1.kr.zone"; allow-update { none; }; };<br>
zone "server2.kr" IN { type master; file "server2.kr.zone"; allow-update { none; }; };<br>
zone "server3.kr" IN { type master; file "server3.kr.zone"; allow-update { none; }; };<br>
<br>
<br>
2.2. 포워드 존파일 생성<br>
<br>
/etc/named.rfc1912.zones 에 저장된 도메인에 해당하는 파일을 생성한다.<br>
/etc/named.conf : directory "/var/named";<br>
/etc/named.rfc1912.zones : file "server1.kr.zone"; , file "server2.kr.zone"; , file "server3.kr.zone";<br>
<br>
<br>
포워드 존파일 : 도메인을 요청했을 때 IP주소 정보를 저장하고 있는 파일<br>
리버스 존파일 : IP주소 정보를 요청했을 때 도메인 정보를 저장하고 있는 파일<br>
<br>
<br>
[root@server1 ~]# cd /var/named/<br>
<br>
<br>
server1.kr 도메인의 포워드 존파일을 생성한다.<br>
<br>
[root@server1 named]# vi server1.kr.zone<br>
<br>
$TTL 60<br>
@      IN      SOA      ns      root ( 2021070201 1D 1H 1W 3H)<br>
          IN      NS      ns<br>
          IN      MX    10 mail<br>
          IN A 192.168.50.20<br>
 ns      IN A 192.168.50.20<br>
mail     IN A 192.168.50.20<br>
www   IN A 192.168.50.20<br>
<br>
<br>
<br>
소유권과 허가권의 권한을 변경한다.<br>
<br>
[root@server1 named]# chgrp named server1.kr.zone <br>
[root@server1 named]# chmod o-r server1.kr.zone <br>
<br>
<br>
server2.kr, server3.kr 도메인의 포워드 존파일을 생성한다.<br>
<br>
[root@server1 named]# cp -a server1.kr.zone server2.kr.zone <br>
[root@server1 named]# cp -a server1.kr.zone server3.kr.zone <br>
<br>
<br>
<br>
2.3. 네임서버 재시작<br>
네임서버를 재시작하기 전에 설정 파일들을 체크한다.<br>
<br>
named-checkconf : /etc/named.rfc1912.zones 체크 <br>
named-checkzone : 포워드 존파일 체크<br>
<br>
<br>
[root@server1 named]# named-checkconf /etc/named.rfc1912.zones<br>
[root@server1 named]# named-checkzone server1.kr server1.kr.zone<br>
[root@server1 named]# named-checkzone server2.kr server2.kr.zone<br>
[root@server1 named]# named-checkzone server3.kr server3.kr.zone<br>
<br>
<br>
<br>
설정파일 체크가 완료되면 네임서버를 재시작한다.<br>
<br>
[root@server1 named]# systemctl restart named<br>
<br>
Job for named.service failed because the control process exited with error co de. See "systemctl status named.service" and "journalctl -xe" for details. = 이와 같이 오류가 낳을 경우 <br>
journalctl -xe를 통해 어느 파일에 어느 부분이 오류가 생겼는지 확인할 수 있다.<br>
<br>
<br>
<br>
2.4. 도메인 질의<br>
여기서는 가상으로 도메인을 사용해야 되기 때문에 /etc/resolv.conf 파일에 네임서버가 <br>
192.168.50.20 인지 확인한다. 만약 192.168.50.20 이 아니면 nmtui에서 영구적으로 설정하거나 <br>
/etc/resolv.conf 파일을 임시적으로 변경한다.<br>
<br>
<br>
192.168.50.20에서 실행한다.<br>
<br>
[root@www ~]# cat /etc/resolv.conf<br>
<br>
# Generated by NetworkManager<br>
search server1.kr<br>
nameserver 192.168.50.20<br>
<br>
<br>
nslookup, dig 으로 도메인을 질의한다. <br>
질의한 결과로는 192.168.50.20이 출력되어야 한다.<br>
<pre><code>
[root@www ~]# yum -y install bind-utils
[root@www ~]# nslookup server1.kr
[root@www ~]# nslookup server2.kr
[root@www ~]# nslookup server3.kr
[root@www ~]# nslookup www.server1.kr
[root@www ~]# nslookup www.server2.kr
[root@www ~]# nslookup www.server3.kr
</pre></code>
<pre><code>
[root@www ~]# dig server1.kr
[root@www ~]# dig server2.kr
[root@www ~]# dig server3.kr
[root@www ~]# dig www.server1.kr
[root@www ~]# dig www.server2.kr
[root@www ~]# dig www.server3.kr
</pre></code>
<br>
<br>
dig(domain informaion groper)는 DNS이름 서버를 쿼리하는 강력한 명령줄 도구<br>
dig 명령은 사용하면 호스트 주소, 메일 교환 및 이름 서버를 비록한 다양한 DNS 레코드에 대한 정보를 쿼리할 수 있다. <br>
(DNS 레코드에 정보를 저장하고 덕분에 유연성과 사용 편의성을 해결해준다)<br>
쿼리 = 사용자 -> 쿼리 -> DB 서버 = DB에서 사용하는 명령어를 쿼리라고 한다.<br>
            사용자 <- 결과 <- DB 서버<br>
            <br>
            <br>
3. 웹서버 구축<br>
- APM(Apache + PHP + MariaDB) 환경이 운영될 수 있도록 패키지를 설치한다.<br>
- 웹서버에 보안서버(HTTPS)가 동작할 수 있도록 인증서를 설치하고 등록한다.<br>
- 인증서는 www.server1.kr 도메인에만 적용한다.<br>
- 인증서 생성 시 각 파일명은 아래와 같다.<br>
csr 파일 key 파일 crt 파일<br>
<br>
server1.kr.csr server1.kr.key server1.kr.crt<br>
<br>
Apache : 웹서버 (httpd)<br>
Php : 프로그래밍 언어 (php)<br>
MariaDB : 데이터베이스 서버 (mariadb-server), 클라이언트 (mariadb)<br>
Php 와 MariaDB 연동 : php-mysql<br>
<br>
<br>
<br>
3.1. APM 설치<br>
<br>
192.168.50.20에서 APM관련 패키지를 설치한다.<br>
<br>
[root@www ~]# yum -y install httpd php php-mysql mariadb mariadb-server<br>
<br>
CentOS가 켜질때 자동으로 httpd, mariadb도 같이 켜지는 명령어 (임시로 하고 싶을경우 start)<br>

<pre><code>
[root@www ~]# systemctl enable httpd
[root@www ~]# systemctl enable mariadb
</pre></code>

httpd, mariadb 상태 확인 명령어
<pre><code>
[root@www ~]# systemctl status httpd
[root@www ~]# systemctl status mariadb
</pre></code>
<br>
GD 라이브러리를 설치한다.<br>
GD 라이브러리는 서버를 설치하는데 있어서 무조건 필수라고 생각하면 된다.<br>
<pre><code>
[root@www ~]# yum -y install php-gd gd gd-devel libjpeg libjpeg-devel giflib giflib-devel libpng libpng-devel freetype freetype-devel
</pre></code>
<br>
<br>
3.2. 웹서버 설정 수정<br>
파일의 확장자가 .php, .html이면 php로 인식하는 설정을 한다.<br>
<br>
<pre><code>
[root@www ~]# vi /etc/httpd/conf.d/php.conf
&lt;FilesMatch \.(php|html)$&gt;
SetHandler application/x-httpd-php
&lt;/FilesMatch&gt;

DirectoryIndex index.php index.html​
</pre></code>
​<br>
​​<br>
​​<br>
php 설정파일을 수정한다.​​<br>
date.timezone : 시간대 설정​​<br>
short_open_tag : &lt;?php -&gt &lt;?​​<br>
expose_php : 연동된 정보 출력 여부​​<br>
display_errors : 개발용 On, 운영용 Off​​<br>
개발용 On : PHP 코드가 에러가 발생되면 브라우저 화면에 에러가 출력된다.​​<br>
운영용 Off : /var/log/httpd 로그 디렉터리에 파일로 기록된다.​​<br>
<br>
<pre><code>
[root@www ~]# vi /etc/php.ini


[Date]
date.timezone = Asia/Seoul
short_open_tag = On
expose_php = Off
display_errors = On
​</pre></code>
<br>
* 만약에 short_open_tag가 여러개 잇으면 n으로 다음을 찾을 수 있음<br>
php 설정이 완료되면 웹서버를 시작한다.<br>
<pre><code>
[root@www ~]# systemctl start httpd
​</pre></code>
80번 포트가 잘 열려있는지 확인한다.<br>
<pre><code>
[root@www ~]# ss -nltp
[root@www ~]# netstat -nltp
​</pre></code>
<br>
3.3. 웹 문서 작성<br>
웹 문서를 /var/www/html 디렉터리에 만들어서 연동이 잘 되었는지 확인한다.<br>
​<pre><code>
[root@www ~]# cd /var/www/html/
[root@www html]# vi index.html

&lt;html&gt; 
&lt;head&gt;
&lt;title&gt; test server &lt;/title&gt;
&lt;meta charset=utf-8&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?
phpinfo();
?&gt;
&lt;/body&gt;
&lt;/html&gt;

​</pre></code>

3.4 filewalld 방화벽 중지<br>
firewalld 방화벽을 중지시키고 서비스를 비활성화 한다.<br>
방화벽은 7에서 다시 설정할 것이고 여기서는 모두 해제한다.<br>
​<pre><code>
[root@www ~]# systemctl stop firewalld
[root@www ~]# systemctl disable firewalld
​</pre></code>
3.5. 웹서버 접속 <br>
http://192.168.50.20/ 로 접속해서 PHP 연동 페이지가 보이는지 확인한다.<br>
잘 동작이 되면 index.html 파일은 보안상 phpinfo(); 의 내용을 삭제한다.<br>
​<pre><code>
[root@www html]# > index.html
​</pre></code>
php -m 명령어로도 연동 모듈들을 확인할 수 있다.<br>
php : /usr/bin/php 
​<pre><code>
[root@www html]# php -m
[PHP Modules]
bz2
calendar
Core
ctype
curl
date
ereg
:
:(생략)
​</pre></code>
_________________________________________<br>
2021/10/19일 여기까지......

</body>
</html>