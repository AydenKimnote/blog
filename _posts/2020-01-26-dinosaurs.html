---
layout: post
title: "Dinosaurs are extinct today"
subtitle: "because they lacked opposable thumbs and the brainpower to build a space program."
date: 2020-01-26 23:45:13 -0400
background: '/img/posts/01.jpg'
---


오늘은 원래 vmware ESXi를 이용하여 gnuboard를 작성하는 법을 배웠으나....
컴퓨터의 사양 딸림으로 인해 vmware workstation에서 다시 gnuboard를 만들어보자...

CentOS7에서 구축한다.

DNS 서버 : 도메인주소를 IP주소로 변환하는 서버
WEB 서버 : 웹 페이지를 제공하는 서버
DB 서버 : 자료를 저장하는 서버
APM  = (Apache + PHP + MySQL)

+------+
|  DNS |
|  WEB |
|   DB |
+------+ 

위에서 설정한 조건에 맞게 문제를 해결한다.


1. 리눅스 서버 설치
- 이 단계에서는 서버로 활용하기 위해서 CentOS7를 설치해주고, IP주소와 파티션을 설정한다.
- 파티션을 확인하는 명령어 = [root@www ~]# fdisk -l
- 파티션의 용량과 mount된 디텍토리 주소 확인하는 명령어 = [root@www ~]# df
- swap : HDD를 메모리처럼 사용하는 기술, 리눅스 설치할 때 반드시 swap 파티션을 나눠줘야 한다. (swap 파티션 용량은 일반적으로 메모리의 2배의 크기로 설정한다.)


2, 호스트명을 설정하는 방법
- 방법1, hostnamectl 명령어를 이용해서 변경하는 방법
- 방법2, nmtui 명령어를 이용해서 변경하는 방법
- 호스트명이 저장되는 파일 : /etc/hostname
- 현재 호스트명을 확인하는 명령어 : hostname


호스트명을 변경하고 /etc/hosts 파일에 호스트명을 추가한다.

# vi /etc/hosts
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.50.30 server1.kr www.server1.kr
192.168.50.30 server2.kr www.server2.kr
192.168.50.30 server3.kr www.server3.kr

​

DNS 설정 정보를 확인한다.

[root@www ~]# cat /etc/resolv.conf
# Generated by NetworkManager
search server1.kr
nameserver 192.168.50.20


3. 도메인 설정
- server1.kr, sever2.kr, server3.kr 
- 192.168.50.25 DNS 서버에 도메인 정보를 설정한다.
- 도메인 정보

도메인명 포워드 존파일 리버스 존파일 IP주소 

server1.kr server1.kr.zone x 192.168.50.20
server2.kr server2.kr.zone x 192.168.50.20
server3.kr server3.kr.zone x 192.168.50.20



2.1. 도메인 등록
네임서버 전체 환경 설정 파일 : /etc/named.conf
도메인 설정 파일 : /etc/named.rfc1912.zones



DNS 패키지인 bind를 설치한다.

# yum -y install bind*

만약 bind*가 설치 되지 않는다면 vi /etc/sysconfig/network-scripts/ifcfg-ens33에 들어가서
맨 밑에 DNS를 추가해줘야한다. DNS1=8.8.8.8 이후 systemctl restart network



/etc/named.conf 파일을 아래와 같이 설정한다.
아래 두 개의 설정을 no로 설정해야 클라이언트에서 yum 요청시 패키지를 설치할 수 있다.

dnssec-enable no;
dnssec-validation no;

[root@server1 ~]# vi /etc/named.conf
listen-on port 53 { 192.168.50.20; };
// listen-on-v6 port 53 { ::1; };
allow-query { any; };
allow-transfer { none; };
version "";
recursion yes;
dnssec-enable no;
dnssec-validation no;



/etc/named.rfc1912.zones 파일에 도메인을 등록한다.
등록하는 형식은 아래처럼 등록해야 한다.

zone "도메인명" IN {
type 네임서버종류;
file "포워드존파일";
allow-update { none; };
};



/etc/named.rfc1912.zones 파일에 도메인을 설정한다.

[root@server1 ~]# vi /etc/named.rfc1912.zones
:
:(생략)
zone "server1.kr" IN { type master; file "server1.kr.zone"; allow-update { none; }; };
zone "server2.kr" IN { type master; file "server2.kr.zone"; allow-update { none; }; };
zone "server3.kr" IN { type master; file "server3.kr.zone"; allow-update { none; }; };


2.2. 포워드 존파일 생성

/etc/named.rfc1912.zones 에 저장된 도메인에 해당하는 파일을 생성한다.
/etc/named.conf : directory "/var/named";
/etc/named.rfc1912.zones : file "server1.kr.zone"; , file "server2.kr.zone"; , file "server3.kr.zone";


포워드 존파일 : 도메인을 요청했을 때 IP주소 정보를 저장하고 있는 파일
리버스 존파일 : IP주소 정보를 요청했을 때 도메인 정보를 저장하고 있는 파일


[root@server1 ~]# cd /var/named/


server1.kr 도메인의 포워드 존파일을 생성한다.

[root@server1 named]# vi server1.kr.zone

$TTL 60
@      IN      SOA      ns      root ( 2021070201 1D 1H 1W 3H)
          IN      NS      ns
          IN      MX    10 mail
          IN A 192.168.50.20
 ns      IN A 192.168.50.20
mail     IN A 192.168.50.20
www   IN A 192.168.50.20



소유권과 허가권의 권한을 변경한다.

[root@server1 named]# chgrp named server1.kr.zone 
[root@server1 named]# chmod o-r server1.kr.zone 


server2.kr, server3.kr 도메인의 포워드 존파일을 생성한다.

[root@server1 named]# cp -a server1.kr.zone server2.kr.zone 
[root@server1 named]# cp -a server1.kr.zone server3.kr.zone 



2.3. 네임서버 재시작
네임서버를 재시작하기 전에 설정 파일들을 체크한다.

named-checkconf : /etc/named.rfc1912.zones 체크 
named-checkzone : 포워드 존파일 체크


[root@server1 named]# named-checkconf /etc/named.rfc1912.zones
[root@server1 named]# named-checkzone server1.kr server1.kr.zone
[root@server1 named]# named-checkzone server2.kr server2.kr.zone
[root@server1 named]# named-checkzone server3.kr server3.kr.zone



설정파일 체크가 완료되면 네임서버를 재시작한다.

[root@server1 named]# systemctl restart named

Job for named.service failed because the control process exited with error co de. See "systemctl status named.service" and "journalctl -xe" for details. = 이와 같이 오류가 낳을 경우 
journalctl -xe를 통해 어느 파일에 어느 부분이 오류가 생겼는지 확인할 수 있다.

 

2.4. 도메인 질의
여기서는 가상으로 도메인을 사용해야 되기 때문에 /etc/resolv.conf 파일에 네임서버가 
192.168.50.20 인지 확인한다. 만약 192.168.50.20 이 아니면 nmtui에서 영구적으로 설정하거나 
/etc/resolv.conf 파일을 임시적으로 변경한다.


192.168.50.20에서 실행한다.

[root@www ~]# cat /etc/resolv.conf

# Generated by NetworkManager
search server1.kr
nameserver 192.168.50.20


nslookup, dig 으로 도메인을 질의한다. 
질의한 결과로는 192.168.50.20이 출력되어야 한다.
''' shell
[root@www ~]# yum -y install bind-utils
[root@www ~]# nslookup server1.kr
[root@www ~]# nslookup server2.kr
[root@www ~]# nslookup server3.kr
[root@www ~]# nslookup www.server1.kr
[root@www ~]# nslookup www.server2.kr
[root@www ~]# nslookup www.server3.kr
''''
'''' shell
[root@www ~]# dig server1.kr
[root@www ~]# dig server2.kr
[root@www ~]# dig server3.kr
[root@www ~]# dig www.server1.kr
[root@www ~]# dig www.server2.kr
[root@www ~]# dig www.server3.kr
'''


dig(domain informaion groper)는 DNS이름 서버를 쿼리하는 강력한 명령줄 도구
dig 명령은 사용하면 호스트 주소, 메일 교환 및 이름 서버를 비록한 다양한 DNS 레코드에 대한 정보를 쿼리할 수 있다. 
(DNS 레코드에 정보를 저장하고 덕분에 유연성과 사용 편의성을 해결해준다)
쿼리 = 사용자 -> 쿼리 -> DB 서버 = DB에서 사용하는 명령어를 쿼리라고 한다.
            사용자 <- 결과 <- DB 서버


3. 웹서버 구축
- APM(Apache + PHP + MariaDB) 환경이 운영될 수 있도록 패키지를 설치한다.
- 웹서버에 보안서버(HTTPS)가 동작할 수 있도록 인증서를 설치하고 등록한다.
- 인증서는 www.server1.kr 도메인에만 적용한다.
- 인증서 생성 시 각 파일명은 아래와 같다.
csr 파일 key 파일 crt 파일

server1.kr.csr server1.kr.key server1.kr.crt

Apache : 웹서버 (httpd)
Php : 프로그래밍 언어 (php)
MariaDB : 데이터베이스 서버 (mariadb-server), 클라이언트 (mariadb)
Php 와 MariaDB 연동 : php-mysql



3.1. APM 설치

192.168.50.20에서 APM관련 패키지를 설치한다.

[root@www ~]# yum -y install httpd php php-mysql mariadb mariadb-server

CentOS가 켜질때 자동으로 httpd, mariadb도 같이 켜지는 명령어 (임시로 하고 싶을경우 start)
''' shell
[root@www ~]# systemctl enable httpd
[root@www ~]# systemctl enable mariadb
''' 

httpd, mariadb 상태 확인 명령어
''' shell
[root@www ~]# systemctl status httpd
[root@www ~]# systemctl status mariadb
''' 

GD 라이브러리를 설치한다.
GD 라이브러리는 서버를 설치하는데 있어서 무조건 필수라고 생각하면 된다.
''' shell
[root@www ~]# yum -y install php-gd gd gd-devel libjpeg libjpeg-devel giflib giflib-devel libpng libpng-devel freetype freetype-devel
''' 


3.2. 웹서버 설정 수정
파일의 확장자가 .php, .html이면 php로 인식하는 설정을 한다.

[root@www ~]# vi /etc/httpd/conf.d/php.conf
''' shell
<FilesMatch \.(php|html)$>

SetHandler application/x-httpd-php

</FilesMatch>
'''
​

DirectoryIndex index.php index.html

​

php 설정파일을 수정한다.

date.timezone : 시간대 설정

short_open_tag : <?php -> <?

expose_php : 연동된 정보 출력 여부

display_errors : 개발용 On, 운영용 Off

개발용 On : PHP 코드가 에러가 발생되면 브라우저 화면에 에러가 출력된다.

운영용 Off : /var/log/httpd 로그 디렉터리에 파일로 기록된다.

[root@www ~]# vi /etc/php.ini

​

[Date]

date.timezone = Asia/Seoul

​

short_open_tag = On

expose_php = Off

display_errors = On

​

* 만약에 short_open_tag가 여러개 잇으면 n으로 다음을 찾을 수 있음

php 설정이 완료되면 웹서버를 시작한다.

[root@www ~]# systemctl start httpd

​

80번 포트가 잘 열려있는지 확인한다.

[root@www ~]# ss -nltp

[root@www ~]# netstat -nltp

​

3.3. 웹 문서 작성

웹 문서를 /var/www/html 디렉터리에 만들어서 연동이 잘 되었는지 확인한다.

[root@www ~]# cd /var/www/html/

[root@www html]# vi index.html

<html>

<head>

<title> test server </title>

<meta charset=utf-8>

</head>

​

<body>

<?

phpinfo();

?>

</body>

​

</html>

​

3.4 filewalld 방화벽 중지

firewalld 방화벽을 중지시키고 서비스를 비활성화 한다.

방화벽은 7에서 다시 설정할 것이고 여기서는 모두 해제한다.

[root@www ~]# systemctl stop firewalld

[root@www ~]# systemctl disable firewalld

​

3.5. 웹서버 접속 

http://192.168.50.20/ 로 접속해서 PHP 연동 페이지가 보이는지 확인한다.

잘 동작이 되면 index.html 파일은 보안상 phpinfo(); 의 내용을 삭제한다.

[root@www html]# > index.html

​

php -m 명령어로도 연동 모듈들을 확인할 수 있다.

php : /usr/bin/php 

[root@www html]# php -m

[PHP Modules]

bz2

calendar

Core

ctype

curl

date

ereg

:

:(생략)

​

____________________________________________________________________________________________________________

2021/10/19일 여기까지......